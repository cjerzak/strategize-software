
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "strategize"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "strategize-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('strategize')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("build_backend")
> ### * build_backend
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: build_backend
> ### Title: Build the environment for 'strategize'. Creates a conda
> ###   environment in which JAX and NumPy are installed. Users may also
> ###   create such an environment themselves.
> ### Aliases: build_backend
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Create a conda environment named "strategize"
> ##D # and install the required Python packages (jax, numpy, etc.)
> ##D build_backend(conda_env = "strategize", conda = "auto")
> ##D 
> ##D # If you want to specify a particular conda path:
> ##D # build_backend(conda_env = "strategize", conda = "/usr/local/bin/conda")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("build_backend", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("check_hessian_geometry")
> ### * check_hessian_geometry
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_hessian_geometry
> ### Title: Check Hessian Geometry at Nash Equilibrium
> ### Aliases: check_hessian_geometry
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Run adversarial strategize
> ##D result <- strategize(Y = y, W = w, adversarial = TRUE, nSGD = 500)
> ##D 
> ##D # Check Hessian geometry
> ##D hess <- check_hessian_geometry(result)
> ##D print(hess)
> ##D 
> ##D # Check if it's a valid saddle point
> ##D if (hess$valid_saddle) {
> ##D   message("Valid Nash equilibrium geometry!")
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_hessian_geometry", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("create_p_list")
> ### * create_p_list
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: create_p_list
> ### Title: Create Baseline Probability List from Data
> ### Aliases: create_p_list
> 
> ### ** Examples
> 
> # Create sample factor matrix
> W <- data.frame(
+   Gender = c("Male", "Female", "Male", "Female"),
+   Age = c("Young", "Old", "Young", "Old")
+ )
> 
> # Uniform probabilities (for balanced designs)
> p_list_uniform <- create_p_list(W, uniform = TRUE)
Created p_list with 2 factor(s):
  Gender: 2 levels (Female, Male)
  Age: 2 levels (Old, Young)
> print(p_list_uniform)
$Gender
Female   Male 
   0.5    0.5 

$Age
  Old Young 
  0.5   0.5 

> # $Gender
> #   Male Female
> #    0.5    0.5
> # $Age
> #   Young    Old
> #     0.5    0.5
> 
> # Observed frequencies
> p_list_observed <- create_p_list(W, uniform = FALSE)
Created p_list with 2 factor(s):
  Gender: 2 levels (Female, Male)
  Age: 2 levels (Old, Young)
> print(p_list_observed)
$Gender
Female   Male 
   0.5    0.5 

$Age
  Old Young 
  0.5   0.5 

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("create_p_list", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cv_strategize")
> ### * cv_strategize
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cv_strategize
> ### Title: Cross-validation for Optimal Stochastic Interventions in
> ###   Conjoint Analysis
> ### Aliases: cv_strategize
> 
> ### ** Examples
> 
> ## No test: 
> # ================================================
> # Cross-validation to select regularization lambda
> # ================================================
> set.seed(123)
> n <- 400  # profiles (200 pairs)
> 
> # Generate factor matrix
> W <- data.frame(
+   Gender = sample(c("Male", "Female"), n, replace = TRUE),
+   Age = sample(c("35", "50", "65"), n, replace = TRUE),
+   Party = sample(c("Dem", "Rep"), n, replace = TRUE)
+ )
> 
> # Simulate outcome with true effects
> latent <- 0.2 * (W$Gender == "Female") + 0.15 * (W$Age == "35")
> prob <- plogis(latent)
> 
> # Create paired forced-choice structure
> pair_id <- rep(1:(n/2), each = 2)
> Y <- numeric(n)
> for (p in unique(pair_id)) {
+   idx <- which(pair_id == p)
+   winner <- sample(idx, 1, prob = prob[idx])
+   Y[idx] <- as.integer(seq_along(idx) == which(idx == winner))
+ }
> profile_order <- rep(1:2, n/2)
> 
> # Cross-validate over lambda values
> # Lower lambda = less regularization = further from baseline
> cv_result <- cv_strategize(
+   Y = Y,
+   W = W,
+   lambda_seq = c(0.01, 0.1, 0.5, 1.0),
+   folds = 2,
+   pair_id = pair_id,
+   respondent_id = pair_id,
+   profile_order = profile_order,
+   diff = TRUE,
+   nSGD = 50,
+   compute_se = FALSE
+ )
Starting CV sequence...
At lambda 1 of 4...
On fold 1
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
On fold 2
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
At lambda 2 of 4...
On fold 1
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
On fold 2
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
At lambda 3 of 4...
On fold 1
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
On fold 2
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
At lambda 4 of 4...
On fold 1
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
On fold 2
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.5146, LogLoss=0.7332, Acc=0.539, Brier=0.2647
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.2427, LogLoss=0.9225, Acc=0.337, Brier=0.3532
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 1
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
Done with CV sequence & starting final run with log(lambda) of -4.61...
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.4306, LogLoss=0.7364, Acc=0.485, Brier=0.2702
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
Done with strategic analysis!
> 
> # View CV results and selected lambda
> print(cv_result$lambda)       # Optimal lambda
[1] 0.01
> print(cv_result$CVInfo)       # Performance at each lambda
  lambda      Qhat        Qse selected   l_bound   u_bound
1   0.01 0.4706720 0.01640800        1 0.4436832 0.4976607
2   0.10 0.4519872 0.02697638        0 0.4076150 0.4963594
3   0.50 0.4422226 0.02787694        0 0.3963691 0.4880761
4   1.00 0.4395569 0.02937795        0 0.3912344 0.4878793
> print(cv_result$pi_star_point) # Optimal distribution
$k1
$k1$Gender
   Female      Male 
0.6492804 0.3507196 

$k1$Age
        35         50         65 
0.81358325 0.04785672 0.13856000 

$k1$Party
      Dem       Rep 
0.3805093 0.6194906 


$k2
$k2$Gender
  Female     Male 
0.477775 0.522225 

$k2$Age
      35       50       65 
0.314375 0.329225 0.356400 

$k2$Party
     Dem      Rep 
0.512425 0.487575 


> print(cv_result$Q_point)       # Expected outcome
          [,1]
[1,] 0.4898889
> ## End(No test)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cv_strategize", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot_best_response_curves")
> ### * plot_best_response_curves
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot_best_response_curves
> ### Title: Plot Dimension-by-Dimension Best-Response Curves from
> ###   Adversarial 'strategize()' Output
> ### Aliases: plot_best_response_curves
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # =====================================================
> ##D # Visualize best-response curves in adversarial mode
> ##D # =====================================================
> ##D # First, fit an adversarial strategize model
> ##D set.seed(42)
> ##D n <- 400
> ##D 
> ##D # Generate data with party structure
> ##D W <- data.frame(
> ##D   Gender = sample(c("Male", "Female"), n, replace = TRUE),
> ##D   Age = sample(c("Young", "Middle", "Old"), n, replace = TRUE)
> ##D )
> ##D 
> ##D # Party affiliations for respondents and candidates
> ##D respondent_party <- sample(c("Dem", "Rep"), n/2, replace = TRUE)
> ##D candidate_party <- rep(c("Dem", "Rep"), n/2)
> ##D 
> ##D Y <- rbinom(n, 1, 0.5)  # Simplified outcome
> ##D 
> ##D # Fit adversarial model
> ##D adv_result <- strategize(
> ##D   Y = Y,
> ##D   W = W,
> ##D   lambda = 0.1,
> ##D   adversarial = TRUE,
> ##D   competing_group_variable_respondent = rep(respondent_party, each = 2),
> ##D   competing_group_variable_candidate = candidate_party,
> ##D   nSGD = 100
> ##D )
> ##D 
> ##D # Plot best-response curves for Gender dimension (d_ = 1)
> ##D # Shows how each party's optimal Gender distribution responds
> ##D # to changes in the other party's Gender distribution
> ##D plot_best_response_curves(
> ##D   res = adv_result,
> ##D   d_ = 1,  # Gender is first factor
> ##D   nPoints_br = 50,
> ##D   title = "Gender: Best-Response Curves",
> ##D   col_ast = "blue",   # Democrats
> ##D   col_dag = "red"     # Republicans
> ##D )
> ##D 
> ##D # Intersection point indicates Nash equilibrium for this dimension
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot_best_response_curves", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot_convergence")
> ### * plot_convergence
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot_convergence
> ### Title: Plot Convergence Diagnostics for Strategize Results
> ### Aliases: plot_convergence
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Run adversarial strategize
> ##D result <- strategize(Y = y, W = w, adversarial = TRUE, nSGD = 500)
> ##D 
> ##D # Plot convergence diagnostics
> ##D plot_convergence(result)
> ##D 
> ##D # Plot only gradient magnitudes with log scale
> ##D plot_convergence(result, metrics = "gradient", log_scale = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot_convergence", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot_quadrant_breakdown")
> ### * plot_quadrant_breakdown
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot_quadrant_breakdown
> ### Title: Plot Four-Quadrant Contribution Breakdown
> ### Aliases: plot_quadrant_breakdown
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Run adversarial strategize
> ##D result <- strategize(Y = y, W = w, adversarial = TRUE, nSGD = 500)
> ##D 
> ##D # Plot quadrant breakdown
> ##D breakdown <- plot_quadrant_breakdown(result)
> ##D print(breakdown$weights)
> ##D print(breakdown$contributions)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot_quadrant_breakdown", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("strategize")
> ### * strategize
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: strategize
> ### Title: Estimate Optimal (or Adversarial) Stochastic Interventions for
> ###   Conjoint Experiments
> ### Aliases: strategize
> 
> ### ** Examples
> 
> ## No test: 
> # ============================================
> # Example 1: Basic single-agent optimization
> # ============================================
> # Generate synthetic conjoint data
> set.seed(42)
> n <- 400  # Number of profiles (200 pairs)
> 
> # Factor matrix: candidate attributes
> W <- data.frame(
+   Gender = sample(c("Male", "Female"), n, replace = TRUE),
+   Age = sample(c("Young", "Middle", "Old"), n, replace = TRUE),
+   Party = sample(c("Dem", "Rep"), n, replace = TRUE)
+ )
> 
> # Simulate outcome: Female + Young candidates preferred
> latent <- 0.3 * (W$Gender == "Female") +
+           0.2 * (W$Age == "Young") -
+           0.1 * (W$Age == "Old")
> prob <- plogis(latent)
> 
> # Paired forced-choice: within each pair, one wins
> pair_id <- rep(1:(n/2), each = 2)
> Y <- numeric(n)
> for (p in unique(pair_id)) {
+   idx <- which(pair_id == p)
+   winner <- sample(idx, 1, prob = prob[idx])
+   Y[idx] <- as.integer(seq_along(idx) == which(idx == winner))
+ }
> profile_order <- rep(1:2, n/2)
> 
> # Baseline probabilities (uniform assignment)
> p_list <- list(
+   Gender = c(Male = 0.5, Female = 0.5),
+   Age = c(Young = 1/3, Middle = 1/3, Old = 1/3),
+   Party = c(Dem = 0.5, Rep = 0.5)
+ )
> 
> # Run strategize to find optimal distribution
> # (requires conda environment with JAX - see build_backend())
> result <- strategize(
+   Y = Y,
+   W = W,
+   lambda = 0.1,
+   pair_id = pair_id,
+   respondent_id = pair_id,
+   respondent_task_id = pair_id,
+   profile_order = profile_order,
+   p_list = p_list,
+   diff = TRUE,
+   nSGD = 50,
+   compute_se = FALSE
+ )
-------------
strategize() call has begun...
Initializing outcome models...
[1] 1 1
ok_counter = 0
Starting a glinternet fit...
Done with glinternet fit...
ok_counter = 1
GLM OOS fit metrics (pairwise, oos_3fold): AUC=0.4964, LogLoss=0.7283, Acc=0.515, Brier=0.2652
Done initializing outcome models & starting optimization sequence...
Defining some preliminary objects...
Defining Q functions..
Defining gd function...
Starting optimization...
Optimization type: Gradient ascent
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
SGD Iteration: 1 of 50
SGD Iteration: 2 of 50
SGD Iteration: 3 of 50
SGD Iteration: 4 of 50
SGD Iteration: 13 of 50
SGD Iteration: 25 of 50
SGD Iteration: 38 of 50
SGD Iteration: 50 of 50
Saving output from gd [getQPiStar_gd]...
strategize() call has finished...
-------------
> 
> # View optimal distribution
> print(result$pi_star_point)
$k1
$k1$Gender
     Male    Female 
0.3130197 0.6869802 

$k1$Age
    Young    Middle       Old 
0.3336938 0.3336885 0.3326177 

$k1$Party
      Dem       Rep 
0.7099242 0.2900758 


$k2
$k2$Gender
  Male Female 
 0.505  0.495 

$k2$Age
 Young Middle    Old 
 0.335  0.335  0.330 

$k2$Party
  Dem   Rep 
0.505 0.495 


> 
> # View expected outcome under optimal strategy
> print(result$Q_point)
          [,1]
[1,] 0.4979096
> ## End(No test)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("strategize", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("strategize.plot")
> ### * strategize.plot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: strategize.plot
> ### Title: Plot Estimated Probabilities for Hypothetical Scenarios
> ### Aliases: strategize.plot
> 
> ### ** Examples
> 
> # =============================================
> # Visualize optimal vs baseline distributions
> # =============================================
> # This function works without JAX - just needs the result structure
> 
> # Create mock strategize result for plotting
> # (In practice, use output from strategize())
> pi_star_list <- list(k1 = list(
+   Gender = c(Male = 0.35, Female = 0.65),
+   Age = c(Young = 0.45, Middle = 0.30, Old = 0.25),
+   Party = c(Dem = 0.40, Rep = 0.60)
+ ))
> 
> pi_star_se_list <- list(k1 = list(
+   Gender = c(Male = 0.04, Female = 0.04),
+   Age = c(Young = 0.03, Middle = 0.03, Old = 0.03),
+   Party = c(Dem = 0.05, Rep = 0.05)
+ ))
> 
> # Baseline (original assignment) probabilities
> p_list <- list(
+   Gender = c(Male = 0.5, Female = 0.5),
+   Age = c(Young = 0.33, Middle = 0.33, Old = 0.34),
+   Party = c(Dem = 0.5, Rep = 0.5)
+ )
> 
> # Plot comparing optimal to baseline
> strategize.plot(
+   pi_star_list = pi_star_list,
+   pi_star_se_list = pi_star_se_list,
+   p_list = p_list,
+   main_title = "Optimal vs Baseline Distribution",
+   ticks_type = "assignmentProbs"  # Show baseline as reference ticks
+ )
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("strategize.plot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("strategize_onestep")
> ### * strategize_onestep
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: strategize_onestep
> ### Title: Estimate an Optimal (or Adversarial) Stochastic Intervention for
> ###   Conjoint Analysis Using a One-Step M-estimation Approach
> ### Aliases: strategize_onestep
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # ================================================
> ##D # One-step M-estimation approach
> ##D # ================================================
> ##D # This approach simultaneously estimates the outcome model and
> ##D # optimal distribution, rather than the two-step approach
> ##D 
> ##D set.seed(123)
> ##D n <- 400
> ##D 
> ##D # Generate factor matrix
> ##D W <- data.frame(
> ##D   Gender = sample(c("Male", "Female"), n, replace = TRUE),
> ##D   Age = sample(c("Young", "Middle", "Old"), n, replace = TRUE),
> ##D   Party = sample(c("Dem", "Rep"), n, replace = TRUE)
> ##D )
> ##D 
> ##D # Simulate outcome (Female and Young preferred)
> ##D latent <- 0.3 * (W$Gender == "Female") + 0.2 * (W$Age == "Young")
> ##D Y <- rbinom(n, 1, plogis(latent))
> ##D 
> ##D # Baseline probabilities (uniform)
> ##D p_list <- list(
> ##D   Gender = c(Male = 0.5, Female = 0.5),
> ##D   Age = c(Young = 1/3, Middle = 1/3, Old = 1/3),
> ##D   Party = c(Dem = 0.5, Rep = 0.5)
> ##D )
> ##D 
> ##D # Optional respondent covariates
> ##D X <- matrix(rnorm(n * 2), n, 2)
> ##D colnames(X) <- c("Income", "Education")
> ##D 
> ##D # Run one-step estimation
> ##D result <- strategize_onestep(
> ##D   W = W,
> ##D   Y = Y,
> ##D   X = X,
> ##D   p_list = p_list,
> ##D   nSGD = 100,
> ##D   penalty_type = "LogMaxProb",
> ##D   lambda_seq = c(0.01, 0.1),
> ##D   test_fraction = 0.3,
> ##D   quiet = TRUE
> ##D )
> ##D 
> ##D # View optimal distribution
> ##D print(result$pi_star_point)
> ##D 
> ##D # View expected outcome under optimal strategy
> ##D print(result$Q_point)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("strategize_onestep", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("strategize_preset")
> ### * strategize_preset
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: strategize_preset
> ### Title: Get Recommended Parameter Settings
> ### Aliases: strategize_preset
> 
> ### ** Examples
> 
> ## No test: 
> # Get standard settings
> params <- strategize_preset("standard")
Using 'standard' preset:
  nSGD = 100, compute_se = TRUE
  lambda = 0.10 (override with cv_strategize for optimal selection)
> print(params)
$nSGD
[1] 100

$nMonte_adversarial
[1] 24

$nMonte_Qglm
[1] 100

$compute_se
[1] TRUE

$lambda
[1] 0.1

$conf_level
[1] 0.95

> 
> # Use with strategize (hypothetically)
> # result <- do.call(strategize, c(list(Y = Y, W = W, p_list = p_list), params))
> ## End(No test)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("strategize_preset", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("summarize_adversarial")
> ### * summarize_adversarial
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summarize_adversarial
> ### Title: Summarize Adversarial Strategize Results
> ### Aliases: summarize_adversarial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Run adversarial strategize
> ##D result <- strategize(Y = y, W = w, adversarial = TRUE, nSGD = 500)
> ##D 
> ##D # Print summary
> ##D summarize_adversarial(result)
> ##D 
> ##D # Quick summary without validation
> ##D summarize_adversarial(result, validate = FALSE)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summarize_adversarial", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("validate_equilibrium")
> ### * validate_equilibrium
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: validate_equilibrium
> ### Title: Validate Nash Equilibrium Quality
> ### Aliases: validate_equilibrium
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Run adversarial strategize
> ##D result <- strategize(Y = y, W = w, adversarial = TRUE, nSGD = 500)
> ##D 
> ##D # Validate equilibrium
> ##D validation <- validate_equilibrium(result)
> ##D print(validation$is_equilibrium)
> ##D print(validation$br_error_ast)
> ##D print(validation$br_error_dag)
> ##D 
> ##D # If validation fails, try more SGD iterations
> ##D if (!validation$is_equilibrium) {
> ##D   result2 <- strategize(Y = y, W = w, adversarial = TRUE, nSGD = 2000)
> ##D   validation2 <- validate_equilibrium(result2)
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("validate_equilibrium", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  53.532 1.931 27.228 1.215 0.354 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
